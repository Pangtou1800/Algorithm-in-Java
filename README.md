# Algorithm-in-Java - Java数据结构与算法

## 第一章 导言

### 1.1 几个经典的面试题

    > 字符串匹配问题
        ·暴力匹配
        ·KMP算法 - 部分匹配表

    > 汉诺塔问题
        ·分治法

    > 八皇后问题
        ·回溯法

    > 骑士周游问题
        ·DFS
        ·贪心法优化

### 1.2 数据结构和算法的重要性

    1.算法是程序的灵魂，优秀的程序可以在海量数据计算时依然保持高速

    2.一般来讲程序会使用内存计算框架（如Spark）和缓存技术（如Redis）等来优化程序，
      这些程序的核心功能就是算法

    3.实际工作中要支撑高并发量

    4.程序员的门槛也越来越高，面试肯定会考察算法

    5.算法学习也是程序员提升的必经之路

## 第二章 数据结构和算法概述

### 2.1 数据结构和算法的关系

    ·数据结构 - data structure 是一门研究组织数据方式的学科，有了编程语言也就有了数据结构。

    ·数据结构是算法的基础

    ·程序 = 数据结构 + 算法

### 2.2 几个实际编程中遇到的问题

    1. "aabbcc".replace("aa", "dd")

        标准库是怎么做的？

    2.试写出用单链表表示的字符串类及字符串节点类的定义，并依次实现：
        ·构造函数
        ·长度计算
        ·串赋值
        ·判断两串相等
        ..

    3.一个五子棋游戏
        ·如何判断输赢？
        ·如何存档？
        ·如何读档？
        ·如何悔棋？

    4.约瑟夫问题/丢手帕问题
        1~n个人，第m个人出列；继续从1开始，第m个人出列...
        求出出队编号序列

    5.修路问题 - 最小生成树（普利姆算法）

    6.最短路径问题 - 弗洛伊德算法

    7.汉诺塔 - 分治法

    8.八皇后问题 - 回溯法

### 2.3 线性结构和非线性结构

    1.线性结构
        ·线性结构是最常用的数据结构，特点是元素之间存在一对一的关系
        ·线性结构有两种不同的存储方式：
            -顺序存储方式
            -链式存储方式
        ·顺序存储方式的线性表称为顺序表，顺序表中存储的元素是连续的
        ·链式存储的线性表称为链表，链表中元素的地址不一定是连续的
        ·线性结构常见的有：
            -数组
            -队列
            -链表
            -栈

    2.非线性结构
        ·二维数组
        ·多维数组
        ·广义表
        ·树结构
        ·图结构

## 第三章 稀疏数组和队列

### 3.1 五子棋存盘和读取

    . . . . . . . . . .
    . . x . . . . . . .
    . . . o . . . . . .
    . . . . . . . . . .
    . . . . . . . . . .
    . . . . . . . . . .
    . . . . . . . . . .
    . . . . . . . . . .

    ↓

    0 0 0 0 0 0 0 0 0 0
    0 0 1 0 0 0 0 0 0 0
    0 0 0 2 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0

    ！该二维数组的大部分值都是默认值0，因此直接保存会记录很多没有意义的数据

### 3.2 稀疏数组

    当一个数组中大部分元素是0，或者为同一个值时，可以用稀疏数组来保存该数组。

    处理方法：
        1.记录一共有几行几列，有多少个不同的值
        2.把具有不同值元素的行列及值记录在一个数组中，就可以缩小保存的规模

    原始二维数组：

        0 0 0 0 0
        0 1 0 0 0
        0 0 3 0 0
        0 0 4 0 0
        0 0 0 0 0

        ↓
    
    稀疏数组：

        行 列 值
        5  5  3
        1  1  1
        2  2  3
        3  4  4

    用12个值就完成了5*5的数组的记录

### 3.3 应用实例

    1.使用稀疏数组，可以保存二维数组（棋盘、地图等）
    2.把稀疏数组存盘，可以恢复到原来的二维数组
    3.思路整理

        二维数组转稀疏数组的思路：

        

            1.遍历原始二维数组，得到有效数据的个数sum
            2.根据sum就可以创建稀疏数组sparseArray int[sum+1][3]
            3.将二维数组的有效数据存入稀疏数组即可

        稀疏数组转二维数组的思路：

            1.先读取稀疏数组的第一行，根据第一行的数据创建原始二维数组 chessArr int[row][col]
            2.再读取稀疏数组后几行的数据，并赋值给原始二维数组

    4.代码实现 - SparseArray.java

### 3.4 银行排队

    先进先出，叫号系统

### 3.5 队列介绍

    ·队列是一个有序列表，可以用数组或链表来实现
    ·遵循先入先出原则

### 3.6 数组模拟队列

    1.队列本身是有序列表，若用数组结构来存储队列，则声明maxSize为其最大容量
    2.队列的输入输出是分别从前后端来处理，因此需要两个变量
        -front 前端
        -rear 后端
     来记录前后端下标，front随着数据输出而改变，rear随着数据输入而改变

    3.思路分析
        1.addQueue - 入队操作
            ·队列不为空，尾指针后移， rear + 1
            ·若队列为空rear = maxSize - 1，则入队失败

    4.代码实现

    5.问题：
        单纯增长下标的方式下，数组只能使用一次，利用率低

### 3.7 数组模拟环形队列

    ·和底层数组接触时均取模后在运算即可    

## 第四章 链表

### 4.1 链表（LinkedList）介绍

    ·链表是有序链表
    ·一个节点中包含
        -数据域
        -下个节点的指针
    ·链表的各个节点不一定连续存放
    ·链表分为带头节点链表和不带头节点链表

### 4.2 水浒英雄排行榜管理

    使用带头节点的单向链表管理水浒英雄的排行榜管理

    方式一：直接添加到链表尾部
    方式二：添加到链表中后保持有序

### 4.3 思路分析

    class HeroNode {
        int no;
        String name;
        String nickName;
        HeroNode next;
    }

    头节点：
        ·不存放具体数据
        ·用来表示单链表头

    ※有序链表？奇怪的数据结构

### 4.4 修改链表的节点的内容

### 4.5 删除链表的节点

### 4.6 双链表

    1.单链表的缺点：
        ·只能从一个方向查找
        ·不能实现自我删除

    2.双链表和单链表的不同：
        ·每个节点都多一个指针，指向上一个节点

### 4.7 单向环形链表

    1.约瑟夫（Josephus）问题

        编号为1, 2, 3... n的人围坐一圈，编号为1的人从1开始报数，
        数到m的人出列。下一个人再从1开始，直到所有人都出列。求出队编号序列。

    2.思路分析
        ·不带头节点的链表
        ·先创建第一个节点，让它指向自身
        ·之后每加入一个新节点，就把该节点加入已有的环中

    3.代码实现 - Josephus.java

## 第五章 栈

### 5.1 计算表达式

     7*2*2*5-5+1-5+3-3 怎么计算出结果？

     其他应用场景：
        ·子程序调用时返回地址记录
        ·处理递归调用
        ·表达式的转换
        ·二叉树遍历
        ·深度优先搜索法 - DFS

### 5.2 栈的介绍

    ·栈 - Stack
    ·栈是一个先入后出 FILO 的有序列表
    ·变化的一段称为栈顶（Top），固定的一段称为栈底（Bottom）

### 5.3 数组模拟栈

    1.思路分析
        ·底层存储结构是数组
        ·定义top表示栈顶，初始化为-1
        ·入栈操作时top++，将数据存入栈中
        ·出栈操作时取出结果，top--

    2.代码实现 - JojaStack.java

### 5.4 链表模拟栈

    代码实现 - JojoStack.java

### 5.5 栈实现综合计算器(中缀表达式)

    1.思路分析
        ·使用双栈结构
        ·解决操作符优先级问题：
            当前操作符入栈时和栈顶操作符优先级比较，
            当前操作符优先级高时可以直接入栈；否则要提前结算

                - 相同优先级的运算顺序应该是从左向右为正确，而栈从右向左计算，

                所以优先级相同时也需要当场结算
        ·全部扫描结束后，数2 符1运算后 结果入数栈；符号栈空时数栈只有一个值，就是结果

### 5.6 前缀、中缀、后缀表达式

    1.前缀表达式 - 波兰表达式

        运算符位于操作符之前

        (3+4)*5-6 <=> -*+3456

    2.前缀表达式求值

        从右向左扫描，遇到数字时压栈；
        遇到运算符时出栈2次，进行运算；
        运算结果再次入栈

    3.中缀表达式

        就是人类熟悉的计算表达式

    4.后缀表达式 - 逆波兰表达式

        运算符位于操作符之后

        (3+4)*5-6 <=> 34+5*6-

### 5.7 逆波兰计算器

    1.要求
        ·输入一个逆波兰表达式，使用栈，计算结果
        ·支持小括号和多位数整数

    2.思路分析
    
    3.代码实现 - RPolishRotationCalculator.calculate()

### 5.8 中缀表达式转后缀表达式

    步骤
        ·遇到低或平优先级的运算符时，提前结算，生成 2 + 1 的逆序表达式
        ·左括号直接入符号栈
        ·右括号一直结算知道遇到左小括号

    代码实现 - RPolishRotationCalculator.toRPolishRotation()

## 第六章 递归

### 6.1 迷宫问题

    1 1 1 1 1 1
    1 * 0 0 0 1
    1 1 1 0 0 1
    1 0 0 0 0 1
    1 0 0 1 0 1
    1 1 1 1 1 1

        

    *能否从左上角到达右下角？

### 6.2 递归简单案例

    1.打印问题

    public void test(int n) {
        if (n > 1) {
            test(n - 1);
        }
        System.out.print(n + " ");
    }

    -test(5)输出什么？
    -1 2 3 4 5

    2.阶乘问题

    public int factorial(int n) {
        if (n == 1) {
            return 1;
        } else {
            return n * factorial(n - 1);
        }
    }

### 6.3 递归的应用

    很多问题的解决都会用到递归

    ·8皇后问题，球和篮子问题，汉诺塔问题，迷宫问题...
    ·很多排序算法也会用到递归，快排，归并..

### 6.4 递归的规则

    1.执行一次方法，就会创建一个独立的空间（Java中就是一个栈帧）
    2.方法的局部变量是独立的
    3.递归必须向退出递归的条件逼近否则就是无限递归

### 6.5 解决迷宫问题

    代码实现 - Labyrinth.java

    ？如何寻找最短路径

    - 虽然这次将迷宫定义为了一个二维数组，1表示墙，0表示路，但是迷宫其实是一个无向无权图。
    - 将数据结构变为图就可以使用BFS来找最短路径了。

### 6.6 八皇后问题

    在8x8的棋盘上拜访八个皇后，八个皇后不能相互攻击（横、竖、斜都不同行）。

    代码实现 - EightQueens.java

    ！求全部解，找到解后不返回继续循环，真正的回溯

## 第7章 排序算法

### 7.1 介绍

    排序也称排序算法（Sort Algorithm），是将一组数据，依指定的顺序进行排列的过程。

    分类：
        1.内部排序
            将需要处理的所有数据加载到内部存储器中进行排序

        

        2.外部排序
            数据量过大，无法全部加载到内存中，需要借助外部存储装置进行排序

    常见的排序算法：
        -内部排序-插入排序-直接插入排序
                        -希尔排序
                -选择排序-简单选择排序
                        -堆排序
                -交换排序-冒泡排序
                        -快速排序
                -归并排序
                -基数排序（桶排序）
        -外部排序
    

### 7.2 算法的时间复杂度

    1.事后统计法

    2.事前估计法

    3.时间频度
        一个算法花费的时间与算法中语句的执行次数成正比。
        一个算法中语句的执行次数称为语句频度或时间频度。
        记为T(n)。
    
    4.时间复杂度
        如果有辅助函数f(n)，当n趋近于无穷大时，T(n)/f(n)的极限值为不等于0的常数，
        则称f(n)是T(n)的同数量级函数。
        记作 T(n)=O(f(n))
    
    5.常见的时间复杂度
        ·常数阶 O(1)
        ·对数阶 O(log n)
        ·线性阶 O(n)
        ·线性对数阶 O(nlogn)
        ·平方阶 O(n^2)
        ·立方阶 O(n^3)
        ·k次方阶 O(n^k)
        ·指数阶 O(2^n)

### 7.3 算法的空间复杂度

    定义为算法所消耗的存储空间

    做算法分析时，更多的关注时间复杂度

### 7.4 冒泡排序

    冒泡排序（Bubble Sorting）

        通过对待排序序列从前向后依次比较相邻元素，逆序则交换。

        优化：如果一趟比较中没有发生交换，则数组有序

            -> 实测这优化非常鸡肋，1000个随机数的比较次数：
                499500 => 497289
    
    代码实现 - Bubble.java

    -- 100 Random Numbers

        [Bubble.sort] compared: 4950
        [Bubble.sort] swaped  : 2689

### 7.5 选择排序

    选择排序（Select Sorting）

        每次都从整个待排数组中找到最小或最大值，并将其交换到合适的位置

        ·交换次数恒定
    
    代码实现 - Select.java

    -- 100 Random Numbers

        [Select.sort] compared: 4950
        [Select.sort] swaped  : 100

### 7.6 插入排序

    插入排序（Insertion Sorting）

        顺序读取元素，构建有序数组

        ·自带比较剪枝
    
    代码实现 - Insertion.java

    -- 100 Random Numbers

        [Insertion.sort] compared: 2783
        [Insertion.sort] swaped  : 2689

### 7.7 希尔排序

    希尔排序（Shell Sorting）

        简单插入排序经过改进之后的一个高效版本，也称为缩小增量排序

        把记录按照下标的一定增量分组，对每组使用直接插入算法排序；
        随着增量逐渐减少，每组包含的对象越来越多；
        当增量减至1时，排序就结束了。

    代码实现 - Shell.java

    -- 100 Random Numbers

    来自<算法4>：
    步长采取：1,4,13,40... (3n+1)

        [Shell.sort] compared: 742
        [Shell.sort] swaped  : 446

    试试别的：
    步长采取：1,3,7,15,31... (2n+1)

        [Shell.sort] compared: 770
        [Shell.sort] swaped  : 337
    
    步长采取：1,5,21,85... (4n+1)

        [Shell.sort] compared: 780
        [Shell.sort] swaped  : 528

    单纯对半：

        [Shell.sort] compared: 893
        [Shell.sort] swaped  : 450

### 7.8 快速排序

    快速排序（QuickSort）

        是对冒泡排序的一种改进。

        通过一趟排序将数据分割成独立的两部分，其中一部分比另外一部分所有数据都小。
        然后再以此方法对每部分递归处理。
        每部分只剩1个元素时，排序就结束了。

    -- 100 Random Numbers

        [Quick.sort] compared: 635
        [Quick.sort] swaped  : 382

    来自<算法4>：
    分割时左右指针各自尽量连续移动：

        [Quick.sort] compared: 689
        [Quick.sort] swaped  : 173

### 7.9 归并排序

    归并排序（Merge Sort）

        利用归并的思想实现的排序方法，采用经典的分治策略。

    -- 100 Random Numbers

        [Merge.sort] compared: 536
        [Merge.sort] copied  : 1344 => Notice there is no 'swap' in merge sort

### 7.10 基数排序

    基数排序（Radix Sort），又称桶排序（Bucket Sort）

        将所有待比较数字统一为同样长度，然后从低位开始依次进行排序
    
    代码实现 - Bucket.java

    -- 100 Random Numbers

        [Bucket.sort] compared: 0
        [Bucket.sort] copied  : 600 => 100*2*3 (scale: 10^3)

        No compare, no swap ~ 小字母表短键桶排序太强啦 ~

### 7.11 常用排序算法时间复杂度比较

|排序算法|平均|最好|最坏|空间|排序方式|稳定|
|---|---|---|---|---|---|---|---|
|冒泡|O(n^2)|O(n)|O(n^2)|O(1)|In-place|稳定|
|选择|O(n^2)|O(n^2)|O(n^2)|O(1)|In-place|不稳定|
|插入|O(n^2)|O(n)|O(n^2)|O(1)|In-place|稳定|
|希尔|O(nlgn)|？|？|O(1)|In-place|不稳定|
|归并|O(nlgn)|O(nlgn)|O(nlgn)|O(n)|Out-place|稳定|
|快速|O(nlgn)|O(nlgn)|O(n^2)|O(lgn)|In-place|不稳定|
|堆|O(nlgn)|O(nlgn)|O(nlgn)|O(1)|In-place|不稳定|
|桶|O(nk)|O(nk)|O(nk)|O(n^2)|Out-place|稳定|

        
